module static-semantics

imports

  data
  expressions-aggregation
  expressions-casts
  expressions-literals
  expressions-logic
  expressions-math
  expressions-multiplicity-operators
  expressions-references
  model
  module
  types

signature

  constructors

    TBoolean  : Type
    TDatetime : Type
    TFloat    : Type
    TInt      : Type
    TString   : Type
    TNoValue  : Type
    TEntity   : occurrence -> Type
    
    TOne               : Mult
    TZeroOrOne         : Mult
    TOneOrMore         : Mult
    TZeroOrMore        : Mult
    TOneOrMoreOrdered  : Mult
    TZeroOrMoreOrdered : Mult
    
    TIncremental      : Strat
    TOnDemand         : Strat
    TEventual         : Strat
    TOnDemandEventual : Strat
    
    TUOne  : MultU
    TUMany : MultU
    
    TTuple : Type * Mult * Strat -> RichType

    IsType      : TypeTest // type classes
    IsNumeric   : TypeTest
    IsString    : TypeTest
    IsBoolean   : TypeTest
    CanCompare  : TypeTest
    CanAdd      : TypeTest
    CanSubtract : TypeTest
    CanDivide   : TypeTest
    
    TNonZeroConst : TNonZeroConst
    TPossiblyZero : TNonZeroConst

  relations

    anti-symmetric, anti-transitive test : Type * TypeTest
    reflexive, anti-symmetric, transitive mulOrd : Mul * Mul
    reflexive, anti-symmetric, transitive strat : Strat * Strat
    reflexive, anti-symmetric, transitive sub : Type * Type
    irreflexive cast : Type * Type
 
  functions
    
    nonZeroConst: Term -> TNonZeroConst {
      Float("0.0") -> TPossiblyZero(),
      Int("0")     -> TPossiblyZero(),
      Float(i)     -> TNonZeroConst(),
      Int(i)       -> TNonZeroConst(),
      expr         -> TPossiblyZero()
    }

    divisionMult : Mult -> Mult {
      (TZeroOrOne() , nonzeroconst)    -> TZeroOrOne(),
      (TZeroOrMore(), nonzeroconst)    -> TZeroOrMore(),
      (TOne()       , TNonZeroConst()) -> TOne(),
      (TOne()       , TPossiblyZero()) -> TZeroOrOne(),
      (TOneOrMore() , TNonZeroConst()) -> TOneOrMore(),
      (TOneOrMore() , TPossiblyZero()) -> TZeroOrMore()
    }

    subtractionType : Type -> Type {
      TInt()      -> TInt(),
      TFloat()    -> TFloat(),
      TDatetime() -> TInt(),
      TNoValue()  -> TNoValue()
    }

    upperboundOne : Mult -> Mult {
      TZeroOrOne()         -> TZeroOrOne(),
      TZeroOrMore()        -> TZeroOrOne(),
      TZeroOrMoreOrdered() -> TZeroOrOne(),
      TOne()               -> TOne(),
      TOneOrMore()         -> TOne(),
      TOneOrMoreOrdered()  -> TOne()
    }

    choiceLeftMult : Mult -> Mult {
      (TOne()              , mult                ) -> TOne(),              // [1,_] -> always left-hand side operand
      (TOneOrMore()        , mult                ) -> TOneOrMore(),        // [1,_] -> always left-hand side operand
      (TOneOrMoreOrdered() , mult                ) -> TOneOrMore(),        // [1,_] -> always left-hand side operand
      (TZeroOrOne()        , mult                ) -> mult,                // [0,1] -> always right-hand side multiplicity
      (mult                , TZeroOrMore()       ) -> ZeroOrMore(),        // [0,_] <+ [0,n) unordered -> always [0,n) unordered
      (mult                , TOneOrMore()        ) -> TOneOrMore(),        // [0,_] <+ [1,n) unordered -> always [1,n) unordered
      (TZeroOrMoreOrdered(), TZeroOrOne()        ) -> ZeroOrMoreOrdered(), // [0,n) ordered -> upper-bound many
      (TZeroOrMoreOrdered(), TOne()              ) -> OneOrMoreOrdered(),  // [0,n) ordered -> upper-bound many
      (TZeroOrMoreOrdered(), TZeroOrMoreOrdered()) -> ZeroOrMoreOrdered(), // [0,n) ordered -> upper-bound many
      (TZeroOrMoreOrdered(), TOneOrMoreOrdered() ) -> OneOrMoreOrdered(),  // [0,n) ordered -> upper-bound many
      (TZeroOrMore()       , TZeroOrOne()        ) -> ZeroOrMore(),        // [0,n) unordered -> upper-bound many, drop ordering
      (TZeroOrMore()       , TOne()              ) -> OneOrMore(),         // [0,n) unordered -> upper-bound many, drop ordering
      (TZeroOrMore()       , TZeroOrMoreOrdered()) -> ZeroOrMore(),        // [0,n) unordered -> upper-bound many, drop ordering
      (TZeroOrMore()       , TOneOrMoreOrdered() ) -> OneOrMore()          // [0,n) unordered -> upper-bound many, drop ordering
    }
 
    mergeMult : Mult -> Mult {
      (TOneOrMore()        , mult                ) -> TOneOrMore(),         // [1,_] unordered -> [1,n) unordered
      (mult                , TOneOrMore()        ) -> TOneOrMore(),         // [1,_] unordered -> [1,n) unordered
      (TZeroOrMore()       , TOne()              ) -> TOneOrMore(),         // [0,n) unordered ++ [1,_] -> [1,n) unordered
      (TOne()              , TZeroOrMore()       ) -> TOneOrMore(),         // [0,n) unordered ++ [1,_] -> [1,n) unordered
      (TZeroOrMore()       , TOneOrMoreOrdered() ) -> TOneOrMore(),         // [0,n) unordered ++ [1,_] -> [1,n) unordered
      (TOneOrMoreOrdered() , TZeroOrMore()       ) -> TOneOrMore(),         // [0,n) unordered ++ [1,_] -> [1,n) unordered
      (TZeroOrMore()       , mult                ) -> TZeroOrMore(),        // [0,n) unordered remaining -> [0,n) unordered
      (mult                , TZeroOrMore()       ) -> TZeroOrMore(),        // [0,n) unordered remaining -> [0,n) unordered
      (TZeroOrOne()        , TZeroOrOne()        ) -> TZeroOrMoreOrdered(), // [0,_] ordered ++ [0,_] ordered -> [0,n) ordered
      (TZeroOrOne()        , TZeroOrMoreOrdered()) -> TZeroOrMoreOrdered(), // [0,_] ordered ++ [0,_] ordered -> [0,n) ordered
      (TZeroOrMoreOrdered(), TZeroOrOne()        ) -> TZeroOrMoreOrdered(), // [0,_] ordered ++ [0,_] ordered -> [0,n) ordered
      (TZeroOrMoreOrdered(), TZeroOrMoreOrdered()) -> TZeroOrMoreOrdered(), // [0,_] ordered ++ [0,_] ordered -> [0,n) ordered
      (mult1               , mult2               ) -> TOneOrMoreOrdered()   // rest -> [1,n) ordered
    }
    
    multUpper : Mult -> MultU {
      TZeroOrOne()         -> TUOne(),
      TOne()               -> TUOne(),
      TZeroOrMore()        -> TUMany(),
      TOneOrMore()         -> TUMany(),
      TZeroOrMoreOrdered() -> TUMany(),
      TOneOrMoreOrdered()  -> TUMany()
      
    }
 
rules

  init ^ (init_scope) :=
  
    // type classes
  
    TBoolean()  <test! IsType(),
    TDatetime() <test! IsType(),
    TFloat()    <test! IsType(),
    TInt()      <test! IsType(),
    TString()   <test! IsType(),
    TNoValue()  <test! IsType(),
    
    TFloat()    <test! IsNumeric(),
    TInt()      <test! IsNumeric(),
    TNoValue()  <test! IsNumeric(),

    TString()   <test! IsString(),
    TNoValue()  <test! IsString(),

    TBoolean()  <test! IsBoolean(),
    TNoValue()  <test! IsBoolean(),
    
    TDatetime() <test! CanCompare(),
    TFloat()    <test! CanCompare(),
    TInt()      <test! CanCompare(),
    TString()   <test! CanCompare(),
    TNoValue()  <test! CanCompare(),
    
    TFloat()    <test! CanAdd(),
    TInt()      <test! CanAdd(),
    TString()   <test! CanAdd(),
    TNoValue()  <test! CanAdd(),

    TFloat()    <test! CanDivide(),
    TInt()      <test! CanDivide(),
    TNoValue()  <test! CanDivide(),
  
    // multiplicity/ordering lattice
  
    TOne()               <mulOrd! TZeroOrOne(),         //                 TZeroOrMore()
    TOne()               <mulOrd! TOneOrMoreOrdered(),  //                  /    \
    TZeroOrOne()         <mulOrd! TZeroOrMoreOrdered(), // ZeroOrMoreOrdered()  TOneOrMore()
    TOneOrMoreOrdered()  <mulOrd! TZeroOrMoreOrdered(), //             /    \    /
    TOneOrMoreOrdered()  <mulOrd! TOneOrMore(),         //  TZeroOrOne()  TOneOrMoreOrdered()
    TZeroOrMoreOrdered() <mulOrd! TZeroOrMore(),        //             \    /
    TOneOrMore()         <mulOrd! TZeroOrMore(),        //             TOne()
    
    // strategy lattice
    
    TIncremental() <strat! TOnDemand(),         //      TOnDemandEventual()
    TIncremental() <strat! TEventual(),         //          /       \
    TOnDemand()    <strat! TOnDemandEventual(), //  TEventual()   TOnDemand()
    TEventual()    <strat! TOnDemandEventual(), //          \       /
                                                //        TIncremental()
    // subtype relation 
  
    TNoValue() <sub! TInt(),
    TNoValue() <sub! TFloat(),
    TNoValue() <sub! TBoolean(),
    TNoValue() <sub! TDatetime(),
    TNoValue() <sub! TString(),

    // casting relation
    
    TInt()    <cast! TFloat(),
    TInt()    <cast! TNoValue(),
    TFloat()  <cast! TInt(),
    TFloat()  <cast! TNoValue(),
    TString() <cast! TInt(),
    TString() <cast! TFloat(),
    TString() <cast! TBoolean(),
    TString() <cast! TDatetime(),
    TString() <cast! TNoValue(),

    new init_scope.
 